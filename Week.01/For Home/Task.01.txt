01. И двете форми на използване на mod са верни, тъй като в единия случай имаме префиксна упокттреба, а в другия инфиксна, но трябва да използваме префиксните функции по префиксен начин, което означава, че mod x y е верния вариант. Използваме инфиксен синтаксис тогава когато използваме частично прилагане на функциите.
02. Когато функцията приема два аргумента
03. Четем '$' -> „след“. Приема функция като ляв параветър и израз като десен. Първо изчислява израза и го подава като резултат на функцията в ляво
    С други думи благодарение на него можем да изпускаме скобите и не е необходимо да ги пишем в определени ситуации и кода става по прегледен
04. Четем „Сред“
05. Като използваме '$' намаляваме броя на скобите, използвани в кода и го правим по - четим
06. Казваме, че функцията е дефинирана на функционално ниво, когато в нея не се използват цикли и всяка една функция представлява композиция на други функции
07. Означава да изчистим функцията от итеративни процеси(като използването на цикли) и да я превърнем(да я рефакторираме) в композиция на няколко вложени функции
08. Те ни служат при използването на условни конструкции и са еквивалента на switch case в C++ 
09. Използваме guards вместо if else конструкции винаги, когато е възможно
10. Използваме pattern matching вместо guards винаги, когато е възможно
11. Switch cases
12. При рекурсивния процес имаме:
        - Резултатът се запазва в рекурсивна опашка
        - Рекурсивното извикване е част от израза на функцията(от тялото й)
13. При итеративния процес имаме:
        - Резултатът се съхранява в друга променлива, която се изчислява от помощна функция
        - Рекурсивното извикване не е част от израза на функцията(от тялото й)
14. Да възможно е
15. Така показваме, че стойността на аргумента, ознамен с _ не се използва в дефиницията на функцията
16. Pattern matching е синтактична конструкция в Haskell, която ни позволява преди дефинирането на функцията да изброим corner cases и да зададем стойност, която да връща функцията при достигането на тези кейсове, без да използваме други условни конструкции в тялото на функцията
17. Примери за частично прилагане на функции е примерът roundTwoDigButWithMagic, ако имаме функция addNumber и в тялото имаме addNumber = (+ 2), и такава функция но за умножение или деление или изваждане на число от друго. Всички тези функции приемат едно цяло число и връщат също цяло число
18. Заради приоритета на префиксните функции, който позволява изпускането на скоби и подобряване на четимостта на кода
19. Защото с първите букви от азбуката е прието за добра конвенция да означаваме дефинирането на полиморфни функции
20. Трябва, когато съществува built-in функция да използваме нея вместо на ново да си дефинираме такава


